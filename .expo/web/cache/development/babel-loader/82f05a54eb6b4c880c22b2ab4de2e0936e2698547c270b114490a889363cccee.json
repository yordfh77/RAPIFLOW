{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport { UnavailabilityError } from 'expo-modules-core';\nimport AppState from \"react-native-web/dist/exports/AppState\";\nimport Linking from \"react-native-web/dist/exports/Linking\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport processColor from \"react-native-web/dist/exports/processColor\";\nimport ExponentWebBrowser from \"./ExpoWebBrowser\";\nimport { WebBrowserResultType, WebBrowserPresentationStyle } from \"./WebBrowser.types\";\nexport { WebBrowserResultType, WebBrowserPresentationStyle };\nvar emptyCustomTabsPackages = {\n  defaultBrowserPackage: undefined,\n  preferredBrowserPackage: undefined,\n  browserPackages: [],\n  servicePackages: []\n};\nexport function getCustomTabsSupportingBrowsersAsync() {\n  return _getCustomTabsSupportingBrowsersAsync.apply(this, arguments);\n}\nfunction _getCustomTabsSupportingBrowsersAsync() {\n  _getCustomTabsSupportingBrowsersAsync = _asyncToGenerator(function* () {\n    if (!ExponentWebBrowser.getCustomTabsSupportingBrowsersAsync) {\n      throw new UnavailabilityError('WebBrowser', 'getCustomTabsSupportingBrowsersAsync');\n    }\n    if (Platform.OS !== 'android') {\n      return emptyCustomTabsPackages;\n    } else {\n      return yield ExponentWebBrowser.getCustomTabsSupportingBrowsersAsync();\n    }\n  });\n  return _getCustomTabsSupportingBrowsersAsync.apply(this, arguments);\n}\nexport function warmUpAsync(_x) {\n  return _warmUpAsync.apply(this, arguments);\n}\nfunction _warmUpAsync() {\n  _warmUpAsync = _asyncToGenerator(function* (browserPackage) {\n    if (!ExponentWebBrowser.warmUpAsync) {\n      throw new UnavailabilityError('WebBrowser', 'warmUpAsync');\n    }\n    if (Platform.OS !== 'android') {\n      return {};\n    } else {\n      return yield ExponentWebBrowser.warmUpAsync(browserPackage);\n    }\n  });\n  return _warmUpAsync.apply(this, arguments);\n}\nexport function mayInitWithUrlAsync(_x2, _x3) {\n  return _mayInitWithUrlAsync.apply(this, arguments);\n}\nfunction _mayInitWithUrlAsync() {\n  _mayInitWithUrlAsync = _asyncToGenerator(function* (url, browserPackage) {\n    if (!ExponentWebBrowser.mayInitWithUrlAsync) {\n      throw new UnavailabilityError('WebBrowser', 'mayInitWithUrlAsync');\n    }\n    if (Platform.OS !== 'android') {\n      return {};\n    } else {\n      return yield ExponentWebBrowser.mayInitWithUrlAsync(url, browserPackage);\n    }\n  });\n  return _mayInitWithUrlAsync.apply(this, arguments);\n}\nexport function coolDownAsync(_x4) {\n  return _coolDownAsync.apply(this, arguments);\n}\nfunction _coolDownAsync() {\n  _coolDownAsync = _asyncToGenerator(function* (browserPackage) {\n    if (!ExponentWebBrowser.coolDownAsync) {\n      throw new UnavailabilityError('WebBrowser', 'coolDownAsync');\n    }\n    if (Platform.OS !== 'android') {\n      return {};\n    } else {\n      return yield ExponentWebBrowser.coolDownAsync(browserPackage);\n    }\n  });\n  return _coolDownAsync.apply(this, arguments);\n}\nexport function openBrowserAsync(_x5) {\n  return _openBrowserAsync.apply(this, arguments);\n}\nfunction _openBrowserAsync() {\n  _openBrowserAsync = _asyncToGenerator(function* (url) {\n    var browserParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!ExponentWebBrowser.openBrowserAsync) {\n      throw new UnavailabilityError('WebBrowser', 'openBrowserAsync');\n    }\n    return yield ExponentWebBrowser.openBrowserAsync(url, _processOptions(browserParams));\n  });\n  return _openBrowserAsync.apply(this, arguments);\n}\nexport function dismissBrowser() {\n  return ExponentWebBrowser.dismissBrowser == null ? void 0 : ExponentWebBrowser.dismissBrowser();\n}\nexport function openAuthSessionAsync(_x6, _x7) {\n  return _openAuthSessionAsync.apply(this, arguments);\n}\nfunction _openAuthSessionAsync() {\n  _openAuthSessionAsync = _asyncToGenerator(function* (url, redirectUrl) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (_authSessionIsNativelySupported()) {\n      if (!ExponentWebBrowser.openAuthSessionAsync) {\n        throw new UnavailabilityError('WebBrowser', 'openAuthSessionAsync');\n      }\n      if (['ios', 'macos', 'web'].includes(Platform.OS)) {\n        return ExponentWebBrowser.openAuthSessionAsync(url, redirectUrl, _processOptions(options));\n      }\n      return ExponentWebBrowser.openAuthSessionAsync(url, redirectUrl);\n    } else {\n      return _openAuthSessionPolyfillAsync(url, redirectUrl, options);\n    }\n  });\n  return _openAuthSessionAsync.apply(this, arguments);\n}\nexport function dismissAuthSession() {\n  if (_authSessionIsNativelySupported()) {\n    if (!ExponentWebBrowser.dismissAuthSession) {\n      throw new UnavailabilityError('WebBrowser', 'dismissAuthSession');\n    }\n    ExponentWebBrowser.dismissAuthSession();\n  } else {\n    if (!ExponentWebBrowser.dismissBrowser) {\n      throw new UnavailabilityError('WebBrowser', 'dismissBrowser');\n    }\n    ExponentWebBrowser.dismissBrowser();\n  }\n}\nexport function maybeCompleteAuthSession() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (ExponentWebBrowser.maybeCompleteAuthSession) {\n    return ExponentWebBrowser.maybeCompleteAuthSession(options);\n  }\n  return {\n    type: 'failed',\n    message: 'Not supported on this platform'\n  };\n}\nfunction _processOptions(options) {\n  return _objectSpread(_objectSpread({}, options), {}, {\n    controlsColor: processColor(options.controlsColor),\n    toolbarColor: processColor(options.toolbarColor),\n    secondaryToolbarColor: processColor(options.secondaryToolbarColor)\n  });\n}\nfunction _authSessionIsNativelySupported() {\n  return Platform.OS !== 'android';\n}\nvar _redirectSubscription = null;\nvar _onWebBrowserCloseAndroid = null;\nvar _isAppStateAvailable = AppState.currentState !== null;\nfunction _onAppStateChangeAndroid(state) {\n  if (!_isAppStateAvailable) {\n    _isAppStateAvailable = true;\n    return;\n  }\n  if (state === 'active' && _onWebBrowserCloseAndroid) {\n    _onWebBrowserCloseAndroid();\n  }\n}\nfunction _openBrowserAndWaitAndroidAsync(_x8) {\n  return _openBrowserAndWaitAndroidAsync2.apply(this, arguments);\n}\nfunction _openBrowserAndWaitAndroidAsync2() {\n  _openBrowserAndWaitAndroidAsync2 = _asyncToGenerator(function* (startUrl) {\n    var browserParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var appStateChangedToActive = new Promise(function (resolve) {\n      _onWebBrowserCloseAndroid = resolve;\n    });\n    var stateChangeSubscription = AppState.addEventListener('change', _onAppStateChangeAndroid);\n    var result = {\n      type: WebBrowserResultType.CANCEL\n    };\n    var type = null;\n    try {\n      var _yield$openBrowserAsy = yield openBrowserAsync(startUrl, browserParams);\n      type = _yield$openBrowserAsy.type;\n    } catch (e) {\n      stateChangeSubscription.remove();\n      _onWebBrowserCloseAndroid = null;\n      throw e;\n    }\n    if (type === 'opened') {\n      yield appStateChangedToActive;\n      result = {\n        type: WebBrowserResultType.DISMISS\n      };\n    }\n    stateChangeSubscription.remove();\n    _onWebBrowserCloseAndroid = null;\n    return result;\n  });\n  return _openBrowserAndWaitAndroidAsync2.apply(this, arguments);\n}\nfunction _openAuthSessionPolyfillAsync(_x9, _x0) {\n  return _openAuthSessionPolyfillAsync2.apply(this, arguments);\n}\nfunction _openAuthSessionPolyfillAsync2() {\n  _openAuthSessionPolyfillAsync2 = _asyncToGenerator(function* (startUrl, returnUrl) {\n    var browserParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (_redirectSubscription) {\n      throw new Error(`The WebBrowser's auth session is in an invalid state with a redirect handler set when it should not be`);\n    }\n    if (_onWebBrowserCloseAndroid) {\n      throw new Error(`WebBrowser is already open, only one can be open at a time`);\n    }\n    try {\n      if (Platform.OS === 'android') {\n        return yield Promise.race([_openBrowserAndWaitAndroidAsync(startUrl, browserParams), _waitForRedirectAsync(returnUrl)]);\n      } else {\n        return yield Promise.race([openBrowserAsync(startUrl, browserParams), _waitForRedirectAsync(returnUrl)]);\n      }\n    } finally {\n      if (ExponentWebBrowser.dismissBrowser) {\n        ExponentWebBrowser.dismissBrowser();\n      }\n      _stopWaitingForRedirect();\n    }\n  });\n  return _openAuthSessionPolyfillAsync2.apply(this, arguments);\n}\nfunction _stopWaitingForRedirect() {\n  if (!_redirectSubscription) {\n    throw new Error(`The WebBrowser auth session is in an invalid state with no redirect handler when one should be set`);\n  }\n  _redirectSubscription.remove();\n  _redirectSubscription = null;\n}\nfunction _waitForRedirectAsync(returnUrl) {\n  return new Promise(function (resolve) {\n    var redirectHandler = function redirectHandler(event) {\n      if (returnUrl && event.url.startsWith(returnUrl)) {\n        resolve({\n          url: event.url,\n          type: 'success'\n        });\n      }\n    };\n    _redirectSubscription = Linking.addEventListener('url', redirectHandler);\n  });\n}","map":{"version":3,"names":["UnavailabilityError","AppState","Linking","Platform","processColor","ExponentWebBrowser","WebBrowserResultType","WebBrowserPresentationStyle","emptyCustomTabsPackages","defaultBrowserPackage","undefined","preferredBrowserPackage","browserPackages","servicePackages","getCustomTabsSupportingBrowsersAsync","_getCustomTabsSupportingBrowsersAsync","apply","arguments","_asyncToGenerator","OS","warmUpAsync","_x","_warmUpAsync","browserPackage","mayInitWithUrlAsync","_x2","_x3","_mayInitWithUrlAsync","url","coolDownAsync","_x4","_coolDownAsync","openBrowserAsync","_x5","_openBrowserAsync","browserParams","length","_processOptions","dismissBrowser","openAuthSessionAsync","_x6","_x7","_openAuthSessionAsync","redirectUrl","options","_authSessionIsNativelySupported","includes","_openAuthSessionPolyfillAsync","dismissAuthSession","maybeCompleteAuthSession","type","message","_objectSpread","controlsColor","toolbarColor","secondaryToolbarColor","_redirectSubscription","_onWebBrowserCloseAndroid","_isAppStateAvailable","currentState","_onAppStateChangeAndroid","state","_openBrowserAndWaitAndroidAsync","_x8","_openBrowserAndWaitAndroidAsync2","startUrl","appStateChangedToActive","Promise","resolve","stateChangeSubscription","addEventListener","result","CANCEL","_yield$openBrowserAsy","e","remove","DISMISS","_x9","_x0","_openAuthSessionPolyfillAsync2","returnUrl","Error","race","_waitForRedirectAsync","_stopWaitingForRedirect","redirectHandler","event","startsWith"],"sources":["D:\\HARBOR\\RAPIFLOW\\node_modules\\expo-web-browser\\src\\WebBrowser.ts"],"sourcesContent":["import { UnavailabilityError } from 'expo-modules-core';\nimport {\n  AppState,\n  AppStateStatus,\n  Linking,\n  Platform,\n  EmitterSubscription,\n  processColor,\n} from 'react-native';\n\nimport ExponentWebBrowser from './ExpoWebBrowser';\nimport {\n  RedirectEvent,\n  WebBrowserAuthSessionResult,\n  WebBrowserCompleteAuthSessionOptions,\n  WebBrowserCompleteAuthSessionResult,\n  WebBrowserCoolDownResult,\n  WebBrowserCustomTabsResults,\n  WebBrowserMayInitWithUrlResult,\n  WebBrowserOpenOptions,\n  WebBrowserRedirectResult,\n  WebBrowserResult,\n  WebBrowserResultType,\n  WebBrowserWarmUpResult,\n  WebBrowserWindowFeatures,\n  WebBrowserPresentationStyle,\n  AuthSessionOpenOptions,\n} from './WebBrowser.types';\n\nexport {\n  WebBrowserAuthSessionResult,\n  WebBrowserCompleteAuthSessionOptions,\n  WebBrowserCompleteAuthSessionResult,\n  WebBrowserCoolDownResult,\n  WebBrowserCustomTabsResults,\n  WebBrowserMayInitWithUrlResult,\n  WebBrowserOpenOptions,\n  WebBrowserRedirectResult,\n  WebBrowserResult,\n  WebBrowserResultType,\n  WebBrowserWarmUpResult,\n  WebBrowserWindowFeatures,\n  WebBrowserPresentationStyle,\n  AuthSessionOpenOptions,\n};\n\nconst emptyCustomTabsPackages: WebBrowserCustomTabsResults = {\n  defaultBrowserPackage: undefined,\n  preferredBrowserPackage: undefined,\n  browserPackages: [],\n  servicePackages: [],\n};\n\n// @needsAudit\n/**\n * Returns a list of applications package names supporting Custom Tabs, Custom Tabs\n * service, user chosen and preferred one. This may not be fully reliable, since it uses\n * `PackageManager.getResolvingActivities` under the hood. (For example, some browsers might not be\n * present in browserPackages list once another browser is set to default.)\n *\n * @return The promise which fulfils with [`WebBrowserCustomTabsResults`](#webbrowsercustomtabsresults) object.\n * @platform android\n */\nexport async function getCustomTabsSupportingBrowsersAsync(): Promise<WebBrowserCustomTabsResults> {\n  if (!ExponentWebBrowser.getCustomTabsSupportingBrowsersAsync) {\n    throw new UnavailabilityError('WebBrowser', 'getCustomTabsSupportingBrowsersAsync');\n  }\n  if (Platform.OS !== 'android') {\n    return emptyCustomTabsPackages;\n  } else {\n    return await ExponentWebBrowser.getCustomTabsSupportingBrowsersAsync();\n  }\n}\n\n// @needsAudit\n/**\n * This method calls `warmUp` method on [CustomTabsClient](https://developer.android.com/reference/android/support/customtabs/CustomTabsClient.html#warmup(long))\n * for specified package.\n *\n * @param browserPackage Package of browser to be warmed up. If not set, preferred browser will be warmed.\n *\n * @return A promise which fulfils with `WebBrowserWarmUpResult` object.\n * @platform android\n */\nexport async function warmUpAsync(browserPackage?: string): Promise<WebBrowserWarmUpResult> {\n  if (!ExponentWebBrowser.warmUpAsync) {\n    throw new UnavailabilityError('WebBrowser', 'warmUpAsync');\n  }\n  if (Platform.OS !== 'android') {\n    return {};\n  } else {\n    return await ExponentWebBrowser.warmUpAsync(browserPackage);\n  }\n}\n\n// @needsAudit\n/**\n * This method initiates (if needed) [CustomTabsSession](https://developer.android.com/reference/android/support/customtabs/CustomTabsSession.html#maylaunchurl)\n * and calls its `mayLaunchUrl` method for browser specified by the package.\n *\n * @param url The url of page that is likely to be loaded first when opening browser.\n * @param browserPackage Package of browser to be informed. If not set, preferred\n * browser will be used.\n *\n * @return A promise which fulfils with `WebBrowserMayInitWithUrlResult` object.\n * @platform android\n */\nexport async function mayInitWithUrlAsync(\n  url: string,\n  browserPackage?: string\n): Promise<WebBrowserMayInitWithUrlResult> {\n  if (!ExponentWebBrowser.mayInitWithUrlAsync) {\n    throw new UnavailabilityError('WebBrowser', 'mayInitWithUrlAsync');\n  }\n  if (Platform.OS !== 'android') {\n    return {};\n  } else {\n    return await ExponentWebBrowser.mayInitWithUrlAsync(url, browserPackage);\n  }\n}\n\n// @needsAudit\n/**\n * This methods removes all bindings to services created by [`warmUpAsync`](#webbrowserwarmupasyncbrowserpackage)\n * or [`mayInitWithUrlAsync`](#webbrowsermayinitwithurlasyncurl-browserpackage). You should call\n * this method once you don't need them to avoid potential memory leaks. However, those binding\n * would be cleared once your application is destroyed, which might be sufficient in most cases.\n *\n * @param browserPackage Package of browser to be cooled. If not set, preferred browser will be used.\n *\n * @return The promise which fulfils with ` WebBrowserCoolDownResult` when cooling is performed, or\n * an empty object when there was no connection to be dismissed.\n * @platform android\n */\nexport async function coolDownAsync(browserPackage?: string): Promise<WebBrowserCoolDownResult> {\n  if (!ExponentWebBrowser.coolDownAsync) {\n    throw new UnavailabilityError('WebBrowser', 'coolDownAsync');\n  }\n  if (Platform.OS !== 'android') {\n    return {};\n  } else {\n    return await ExponentWebBrowser.coolDownAsync(browserPackage);\n  }\n}\n\n// @needsAudit\n/**\n * Opens the url with Safari in a modal on iOS using [`SFSafariViewController`](https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller),\n * and Chrome in a new [custom tab](https://developer.chrome.com/multidevice/android/customtabs)\n * on Android. On iOS, the modal Safari will not share cookies with the system Safari. If you need\n * this, use [`openAuthSessionAsync`](#webbrowseropenauthsessionasyncurl-redirecturl-options).\n *\n * @param url The url to open in the web browser.\n * @param browserParams A dictionary of key-value pairs.\n *\n * @return The promise behaves differently based on the platform.\n * On Android promise resolves with `{ type: 'opened' }` if we were able to open browser.\n * On iOS:\n * - If the user closed the web browser, the Promise resolves with `{ type: 'cancel' }`.\n * - If the browser is closed using [`dismissBrowser`](#webbrowserdismissbrowser), the Promise resolves with `{ type: 'dismiss' }`.\n */\nexport async function openBrowserAsync(\n  url: string,\n  browserParams: WebBrowserOpenOptions = {}\n): Promise<WebBrowserResult> {\n  if (!ExponentWebBrowser.openBrowserAsync) {\n    throw new UnavailabilityError('WebBrowser', 'openBrowserAsync');\n  }\n\n  return await ExponentWebBrowser.openBrowserAsync(url, _processOptions(browserParams));\n}\n\n// @needsAudit\n/**\n * Dismisses the presented web browser.\n *\n * @return The promise that resolves with `{ type: 'dismiss' }` on the successful attempt or throws an error if dismiss functionality is not available.\n * @platform ios\n */\nexport function dismissBrowser(): Promise<{ type: WebBrowserResultType.DISMISS }> {\n  return ExponentWebBrowser.dismissBrowser?.();\n}\n\n// @needsAudit\n/**\n * # On Android:\n * This will be done using a \"custom Chrome tabs\" browser, [AppState](https://reactnative.dev/docs/appstate),\n * and [Linking](./linking/) APIs.\n *\n * # On iOS:\n * Opens the url with Safari in a modal using `ASWebAuthenticationSession`. The user will be asked\n * whether to allow the app to authenticate using the given url.\n * To handle redirection back to the mobile application, the redirect URI set in the authentication server\n * has to use the protocol provided as the scheme in **app.json** [`expo.scheme`](./../config/app/#scheme).\n * For example, `demo://` not `https://` protocol.\n * Using `Linking.addEventListener` is not needed and can have side effects.\n *\n * # On web:\n * > This API can only be used in a secure environment (localhost/https).\n * to test this. Otherwise, an error with code [`ERR_WEB_BROWSER_CRYPTO`](#err_web_browser_crypto) will be thrown.\n * This will use the browser's [`window.open()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/open) API.\n * - _Desktop_: This will create a new web popup window in the browser that can be closed later using `WebBrowser.maybeCompleteAuthSession()`.\n * - _Mobile_: This will open a new tab in the browser which can be closed using `WebBrowser.maybeCompleteAuthSession()`.\n *\n * How this works on web:\n * - A crypto state will be created for verifying the redirect.\n *   - This means you need to run with `npx expo start --https`\n * - The state will be added to the window's `localstorage`. This ensures that auth cannot complete\n *   unless it's done from a page running with the same origin as it was started.\n *   Ex: if `openAuthSessionAsync` is invoked on `https://localhost:19006`, then `maybeCompleteAuthSession`\n *   must be invoked on a page hosted from the origin `https://localhost:19006`. Using a different\n *   website, or even a different host like `https://128.0.0.*:19006` for example will not work.\n * - A timer will be started to check for every 1000 milliseconds (1 second) to detect if the window\n *   has been closed by the user. If this happens then a promise will resolve with `{ type: 'dismiss' }`.\n *\n * > On mobile web, Chrome and Safari will block any call to [`window.open()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/open)\n * which takes too long to fire after a user interaction. This method must be invoked immediately\n * after a user interaction. If the event is blocked, an error with code [`ERR_WEB_BROWSER_BLOCKED`](#err_web_browser_blocked) will be thrown.\n *\n * @param url The url to open in the web browser. This should be a login page.\n * @param redirectUrl _Optional_ - The url to deep link back into your app.\n * On web, this defaults to the output of [`Linking.createURL(\"\")`](./linking/#linkingcreateurlpath-namedparameters).\n * @param options _Optional_ - An object extending the [`WebBrowserOpenOptions`](#webbrowseropenoptions).\n * If there is no native AuthSession implementation available (which is the case on Android)\n * these params will be used in the browser polyfill. If there is a native AuthSession implementation,\n * these params will be ignored.\n *\n * @return\n * - If the user does not permit the application to authenticate with the given url, the Promise fulfills with `{ type: 'cancel' }` object.\n * - If the user closed the web browser, the Promise fulfills with `{ type: 'cancel' }` object.\n * - If the browser is closed using [`dismissBrowser`](#webbrowserdismissbrowser),\n * the Promise fulfills with `{ type: 'dismiss' }` object.\n */\nexport async function openAuthSessionAsync(\n  url: string,\n  redirectUrl?: string | null,\n  options: AuthSessionOpenOptions = {}\n): Promise<WebBrowserAuthSessionResult> {\n  if (_authSessionIsNativelySupported()) {\n    if (!ExponentWebBrowser.openAuthSessionAsync) {\n      throw new UnavailabilityError('WebBrowser', 'openAuthSessionAsync');\n    }\n    if (['ios', 'macos', 'web'].includes(Platform.OS)) {\n      return ExponentWebBrowser.openAuthSessionAsync(url, redirectUrl, _processOptions(options));\n    }\n    return ExponentWebBrowser.openAuthSessionAsync(url, redirectUrl);\n  } else {\n    return _openAuthSessionPolyfillAsync(url, redirectUrl, options);\n  }\n}\n\n/**\n * Dismisses the current authentication session. On web, it will close the popup window associated with auth process.\n *\n * @return The `void` on the successful attempt or throws an error if dismiss functionality is not available.\n *\n * @platform ios\n * @platform web\n */\nexport function dismissAuthSession(): void {\n  if (_authSessionIsNativelySupported()) {\n    if (!ExponentWebBrowser.dismissAuthSession) {\n      throw new UnavailabilityError('WebBrowser', 'dismissAuthSession');\n    }\n    ExponentWebBrowser.dismissAuthSession();\n  } else {\n    if (!ExponentWebBrowser.dismissBrowser) {\n      throw new UnavailabilityError('WebBrowser', 'dismissBrowser');\n    }\n    ExponentWebBrowser.dismissBrowser();\n  }\n}\n\n// @needsAudit\n/**\n * Possibly completes an authentication session on web in a window popup. The method\n * should be invoked on the page that the window redirects to.\n *\n * @param options\n *\n * @return Returns an object with message about why the redirect failed or succeeded:\n *\n * If `type` is set to `failed`, the reason depends on the message:\n * - `Not supported on this platform`: If the platform doesn't support this method (Android, iOS).\n * - `Cannot use expo-web-browser in a non-browser environment`: If the code was executed in an SSR\n *   or node environment.\n * - `No auth session is currently in progress`: (the cached state wasn't found in local storage).\n *   This can happen if the window redirects to an origin (website) that is different to the initial\n *   website origin. If this happens in development, it may be because the auth started on localhost\n *   and finished on your computer port (Ex: `128.0.0.*`). This is controlled by the `redirectUrl`\n *   and `returnUrl`.\n * - `Current URL \"<URL>\" and original redirect URL \"<URL>\" do not match`: This can occur when the\n *   redirect URL doesn't match what was initial defined as the `returnUrl`. You can skip this test\n *   in development by passing `{ skipRedirectCheck: true }` to the function.\n *\n * If `type` is set to `success`, the parent window will attempt to close the child window immediately.\n *\n * If the error `ERR_WEB_BROWSER_REDIRECT` was thrown, it may mean that the parent window was\n * reloaded before the auth was completed. In this case you'll need to close the child window manually.\n *\n * @platform web\n */\nexport function maybeCompleteAuthSession(\n  options: WebBrowserCompleteAuthSessionOptions = {}\n): WebBrowserCompleteAuthSessionResult {\n  if (ExponentWebBrowser.maybeCompleteAuthSession) {\n    return ExponentWebBrowser.maybeCompleteAuthSession(options);\n  }\n  return { type: 'failed', message: 'Not supported on this platform' };\n}\n\nfunction _processOptions(options: WebBrowserOpenOptions) {\n  return {\n    ...options,\n    controlsColor: processColor(options.controlsColor),\n    toolbarColor: processColor(options.toolbarColor),\n    secondaryToolbarColor: processColor(options.secondaryToolbarColor),\n  };\n}\n\n/* Android polyfill for ASWebAuthenticationSession flow */\n\nfunction _authSessionIsNativelySupported(): boolean {\n  return Platform.OS !== 'android';\n}\n\nlet _redirectSubscription: EmitterSubscription | null = null;\n\n/*\n * openBrowserAsync on Android doesn't wait until closed, so we need to polyfill\n * it with AppState\n */\n\n// Store the `resolve` function from a Promise to fire when the AppState\n// returns to active\nlet _onWebBrowserCloseAndroid: null | (() => void) = null;\n\n// If the initial AppState.currentState is null, we assume that the first call to\n// AppState#change event is not actually triggered by a real change,\n// is triggered instead by the bridge capturing the current state\n// (https://reactnative.dev/docs/appstate#basic-usage)\nlet _isAppStateAvailable: boolean = AppState.currentState !== null;\nfunction _onAppStateChangeAndroid(state: AppStateStatus) {\n  if (!_isAppStateAvailable) {\n    _isAppStateAvailable = true;\n    return;\n  }\n\n  if (state === 'active' && _onWebBrowserCloseAndroid) {\n    _onWebBrowserCloseAndroid();\n  }\n}\n\nasync function _openBrowserAndWaitAndroidAsync(\n  startUrl: string,\n  browserParams: WebBrowserOpenOptions = {}\n): Promise<WebBrowserResult> {\n  const appStateChangedToActive = new Promise<void>((resolve) => {\n    _onWebBrowserCloseAndroid = resolve;\n  });\n  const stateChangeSubscription = AppState.addEventListener('change', _onAppStateChangeAndroid);\n\n  let result: WebBrowserResult = { type: WebBrowserResultType.CANCEL };\n  let type: string | null = null;\n\n  try {\n    ({ type } = await openBrowserAsync(startUrl, browserParams));\n  } catch (e) {\n    stateChangeSubscription.remove();\n    _onWebBrowserCloseAndroid = null;\n    throw e;\n  }\n\n  if (type === 'opened') {\n    await appStateChangedToActive;\n    result = { type: WebBrowserResultType.DISMISS };\n  }\n\n  stateChangeSubscription.remove();\n  _onWebBrowserCloseAndroid = null;\n  return result;\n}\n\nasync function _openAuthSessionPolyfillAsync(\n  startUrl: string,\n  returnUrl?: string | null,\n  browserParams: WebBrowserOpenOptions = {}\n): Promise<WebBrowserAuthSessionResult> {\n  if (_redirectSubscription) {\n    throw new Error(\n      `The WebBrowser's auth session is in an invalid state with a redirect handler set when it should not be`\n    );\n  }\n\n  if (_onWebBrowserCloseAndroid) {\n    throw new Error(`WebBrowser is already open, only one can be open at a time`);\n  }\n\n  try {\n    if (Platform.OS === 'android') {\n      return await Promise.race([\n        _openBrowserAndWaitAndroidAsync(startUrl, browserParams),\n        _waitForRedirectAsync(returnUrl),\n      ]);\n    } else {\n      return await Promise.race([\n        openBrowserAsync(startUrl, browserParams),\n        _waitForRedirectAsync(returnUrl),\n      ]);\n    }\n  } finally {\n    // We can't dismiss the browser on Android, only call this when it's available.\n    // Users on Android need to manually press the 'x' button in Chrome Custom Tabs, sadly.\n    if (ExponentWebBrowser.dismissBrowser) {\n      ExponentWebBrowser.dismissBrowser();\n    }\n\n    _stopWaitingForRedirect();\n  }\n}\n\nfunction _stopWaitingForRedirect() {\n  if (!_redirectSubscription) {\n    throw new Error(\n      `The WebBrowser auth session is in an invalid state with no redirect handler when one should be set`\n    );\n  }\n\n  _redirectSubscription.remove();\n  _redirectSubscription = null;\n}\n\nfunction _waitForRedirectAsync(returnUrl?: string | null): Promise<WebBrowserRedirectResult> {\n  // Note that this Promise never resolves when `returnUrl` is nullish\n  return new Promise((resolve) => {\n    const redirectHandler = (event: RedirectEvent) => {\n      if (returnUrl && event.url.startsWith(returnUrl)) {\n        resolve({ url: event.url, type: 'success' });\n      }\n    };\n\n    _redirectSubscription = Linking.addEventListener('url', redirectHandler);\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}