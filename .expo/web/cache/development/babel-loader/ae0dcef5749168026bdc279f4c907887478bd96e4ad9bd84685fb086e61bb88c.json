{"ast":null,"code":"import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nexport function requestAsync(_x, _x2) {\n  return _requestAsync.apply(this, arguments);\n}\nfunction _requestAsync() {\n  _requestAsync = _asyncToGenerator(function* (requestUrl, fetchRequest) {\n    var _fetchRequest$dataTyp;\n    var url = new URL(requestUrl);\n    var headers = {};\n    var request = {\n      body: undefined,\n      method: fetchRequest.method,\n      mode: 'cors',\n      headers: headers\n    };\n    var isJsonDataType = ((_fetchRequest$dataTyp = fetchRequest.dataType) == null ? void 0 : _fetchRequest$dataTyp.toLowerCase()) === 'json';\n    if (fetchRequest.headers) {\n      for (var i in fetchRequest.headers) {\n        if (i in fetchRequest.headers) {\n          headers[i] = fetchRequest.headers[i];\n        }\n      }\n    }\n    if (fetchRequest.body) {\n      var _fetchRequest$method;\n      if (((_fetchRequest$method = fetchRequest.method) == null ? void 0 : _fetchRequest$method.toUpperCase()) === 'POST') {\n        request.body = new URLSearchParams(fetchRequest.body).toString();\n      } else {\n        for (var key of Object.keys(fetchRequest.body)) {\n          url.searchParams.append(key, fetchRequest.body[key]);\n        }\n      }\n    }\n    if (isJsonDataType && !headers.Accept && !headers.accept) {\n      headers['Accept'] = 'application/json, text/javascript; q=0.01';\n    }\n    var correctedUrl = url.toString().replace(/\\/$/, '');\n    var response = yield fetch(correctedUrl, request);\n    var contentType = response.headers.get('content-type');\n    if (isJsonDataType || contentType != null && contentType.includes('application/json')) {\n      return response.json();\n    }\n    return response.text();\n  });\n  return _requestAsync.apply(this, arguments);\n}","map":{"version":3,"names":["requestAsync","_x","_x2","_requestAsync","apply","arguments","_asyncToGenerator","requestUrl","fetchRequest","_fetchRequest$dataTyp","url","URL","headers","request","body","undefined","method","mode","isJsonDataType","dataType","toLowerCase","i","_fetchRequest$method","toUpperCase","URLSearchParams","toString","key","Object","keys","searchParams","append","Accept","accept","correctedUrl","replace","response","fetch","contentType","get","includes","json","text"],"sources":["D:\\HARBOR\\RAPIFLOW\\node_modules\\expo-auth-session\\src\\Fetch.ts"],"sourcesContent":["export type Headers = Record<string, string> & {\n  'Content-Type': string;\n  Authorization?: string;\n  Accept?: string;\n};\n\nexport type FetchRequest = {\n  headers?: Headers;\n  body?: Record<string, string>;\n  dataType?: string;\n  method?: string;\n};\n\nexport async function requestAsync<T>(requestUrl: string, fetchRequest: FetchRequest): Promise<T> {\n  const url = new URL(requestUrl);\n\n  const headers: Record<string, string> = {};\n  const request: RequestInit = {\n    body: undefined,\n    method: fetchRequest.method,\n    mode: 'cors',\n    headers,\n  };\n\n  const isJsonDataType = fetchRequest.dataType?.toLowerCase() === 'json';\n\n  if (fetchRequest.headers) {\n    for (const i in fetchRequest.headers) {\n      if (i in fetchRequest.headers) {\n        headers[i] = fetchRequest.headers[i];\n      }\n    }\n  }\n\n  if (fetchRequest.body) {\n    if (fetchRequest.method?.toUpperCase() === 'POST') {\n      request.body = new URLSearchParams(fetchRequest.body).toString();\n    } else {\n      for (const key of Object.keys(fetchRequest.body)) {\n        url.searchParams.append(key, fetchRequest.body[key]);\n      }\n    }\n  }\n\n  if (isJsonDataType && !headers.Accept && !headers.accept) {\n    // NOTE: Github authentication will return XML if this includes the standard `*/*`\n    headers['Accept'] = 'application/json, text/javascript; q=0.01';\n  }\n\n  // Fix a problem with React Native `URL` causing a trailing slash to be added.\n  const correctedUrl = url.toString().replace(/\\/$/, '');\n\n  const response = await fetch(correctedUrl, request);\n\n  const contentType = response.headers.get('content-type');\n  if (isJsonDataType || contentType?.includes('application/json')) {\n    return response.json();\n  }\n  // @ts-ignore: Type 'string' is not assignable to type 'T'.\n  return response.text();\n}\n"],"mappings":";AAaA,gBAAsBA,YAAYA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,aAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AA+CjC,SAAAF,cAAA;EAAAA,aAAA,GAAAG,iBAAA,CA/CM,WAA+BC,UAAkB,EAAEC,YAA0B;IAAA,IAAAC,qBAAA;IAClF,IAAMC,GAAG,GAAG,IAAIC,GAAG,CAACJ,UAAU,CAAC;IAE/B,IAAMK,OAAO,GAA2B,EAAE;IAC1C,IAAMC,OAAO,GAAgB;MAC3BC,IAAI,EAAEC,SAAS;MACfC,MAAM,EAAER,YAAY,CAACQ,MAAM;MAC3BC,IAAI,EAAE,MAAM;MACZL,OAAO,EAAPA;KACD;IAED,IAAMM,cAAc,GAAG,EAAAT,qBAAA,GAAAD,YAAY,CAACW,QAAQ,qBAArBV,qBAAA,CAAuBW,WAAW,EAAE,MAAK,MAAM;IAEtE,IAAIZ,YAAY,CAACI,OAAO,EAAE;MACxB,KAAK,IAAMS,CAAC,IAAIb,YAAY,CAACI,OAAO,EAAE;QACpC,IAAIS,CAAC,IAAIb,YAAY,CAACI,OAAO,EAAE;UAC7BA,OAAO,CAACS,CAAC,CAAC,GAAGb,YAAY,CAACI,OAAO,CAACS,CAAC,CAAC;QACtC;MACF;IACF;IAEA,IAAIb,YAAY,CAACM,IAAI,EAAE;MAAA,IAAAQ,oBAAA;MACrB,IAAI,EAAAA,oBAAA,GAAAd,YAAY,CAACQ,MAAM,qBAAnBM,oBAAA,CAAqBC,WAAW,EAAE,MAAK,MAAM,EAAE;QACjDV,OAAO,CAACC,IAAI,GAAG,IAAIU,eAAe,CAAChB,YAAY,CAACM,IAAI,CAAC,CAACW,QAAQ,EAAE;MAClE,CAAC,MAAM;QACL,KAAK,IAAMC,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACpB,YAAY,CAACM,IAAI,CAAC,EAAE;UAChDJ,GAAG,CAACmB,YAAY,CAACC,MAAM,CAACJ,GAAG,EAAElB,YAAY,CAACM,IAAI,CAACY,GAAG,CAAC,CAAC;QACtD;MACF;IACF;IAEA,IAAIR,cAAc,IAAI,CAACN,OAAO,CAACmB,MAAM,IAAI,CAACnB,OAAO,CAACoB,MAAM,EAAE;MAExDpB,OAAO,CAAC,QAAQ,CAAC,GAAG,2CAA2C;IACjE;IAGA,IAAMqB,YAAY,GAAGvB,GAAG,CAACe,QAAQ,EAAE,CAACS,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;IAEtD,IAAMC,QAAQ,SAASC,KAAK,CAACH,YAAY,EAAEpB,OAAO,CAAC;IAEnD,IAAMwB,WAAW,GAAGF,QAAQ,CAACvB,OAAO,CAAC0B,GAAG,CAAC,cAAc,CAAC;IACxD,IAAIpB,cAAc,IAAImB,WAAW,YAAXA,WAAW,CAAEE,QAAQ,CAAC,kBAAkB,CAAC,EAAE;MAC/D,OAAOJ,QAAQ,CAACK,IAAI,EAAE;IACxB;IAEA,OAAOL,QAAQ,CAACM,IAAI,EAAE;EACxB,CAAC;EAAA,OAAAtC,aAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}